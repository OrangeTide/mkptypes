.TH MKPTYPES 1
.SH NAME
mkptypes \- make prototypes for functions
.SH SYNOPSIS
.B mkptypes
[
.B -e
] [
.B -n
] [
.B -p
.I symbol
] [
.B -s
] [
.B -x
] [
.B -z
] [
.B -A
] [
.B -k
] [
.B -V
] [
.B -W
] [
.I file ...
]
.SH DESCRIPTION
.I Mkptypes
takes as input one or more C source code files, and
produces as output (on the standard output stream) a list of function
prototypes (a la ANSI) for the external functions defined in the
given source files. This output, redirected to a file, is suitable
for #include'ing in a C source file.
.PP
The function definitions in the original source
may be either ``old-style'' (in which case appropriate prototypes are
generated for the functions) or ``new-style'' (in which the definition
includes a prototype already).
.PP
The -e option causes the ``extern'' keyword to be explicitly printed
for external functions. Some non-ANSI compilers may need this.
.PP
The -n option causes the line number where each function was defined
to be prepended to the prototype declaration as a comment.
.PP
The -p option controls the name of the macro used to guard prototype
definitions. Normally this is ``P_'', but you can change it to any string
you like. To eliminate the guard macro entirely, use the -A option.
.PP
The -s option causes prototypes to be generated for functions declared
``static'' as well as extern functions.
.PP
The -x option causes parameter names to be omitted from the output
prototypes. This may be necessary for some brain-damaged pseudo-ANSI
compilers. You may also prefer this style of output. This option has not
been thoroughly tested.
.PP
The -z option suppresses the definition of the prototype macro given by
-p. Header files generated by
.I mkptypes
with this option will not work unless the prototype macro has been defined
elsewhere in the program by the user. Used with the -p option, the -z
option allows use of predefined prototype hiding macros that may exist
on some systems.
.PP
The -A option causes the prototypes emitted to be only readable by ANSI
compilers. This is the default.
.PP
The -k option causes the prototypes are "macro-ized" so that compilers
with __STDC__ not defined don't see them. This is the opposite of the
strict ANSI (-A) option.
.PP
The -V option prints the version number and patchlevel of mkptypes on the
standard error output.
.PP
The -W option supresses the default widening of types in old-style
declarations (e.g. char -> int); use this for C++ compilers or
for supposedly ANSI compilers that don't do type promotion.
.PP
If files are specified on the command line, then a comment specifying
the file of origin is emitted before the prototypes constructed from
that file. If no files are given, then no comments are emitted and
the C source code is taken from the standard input stream.
.SH BUGS
Mkptypes is easily confused by complicated declarations, such as
.nf
         int ((*signal)())() { ...
.fi
or
.nf
         struct foo { int x, y; } foofunc() { ...
.fi
This is because the program doesn't actually understand type definitions.
.PP
Some programs may need to be run through the preprocessor before
being run through
.I mkptypes .
The -n option will not work correctly on preprocessor output if function
definitions (as opposed to declarations) appear in header files.
.PP
Typedef'd types aren't correctly promoted, e.g. for
.nf
        typedef schar char; int foo(x) schar x;...
.fi
.I mkptypes
incorrectly generates the prototype int foo(schar x) rather than the
[correct] int foo(int x).
.PP
Functions named "inline" with no explicit type qualifiers are not
recognized.
.SH SEE ALSO
.I cc
(1),
.I lint
(1).
.SH AUTHOR
Eric R. Smith <ersmith@uwovax.uwo.ca>
.SH NOTE
There is no warranty for this program (as noted above, it's guaranteed
to break sometimes anyways!). Mkptypes is in the public domain.
